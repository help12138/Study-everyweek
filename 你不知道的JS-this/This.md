# 写在前面
> 这篇文章所涉及的所有知识点均来自《你不知道的JS》

从刚开始学习JS关于this的用法就一直一知半解，最初的理解也就仅限于“谁调用它，它指向谁； 在箭头函数里指向自身”这个周末看小黄书的时候，才发现，关于this内容不少，但也不算难，虽然到用的时候还是......以上为前言。下面开始纯纯的干货，又或者说是学习笔记

## 关于this指向问题
` this`的指向在最开始时我以为跟之前学的其它关于面向对象的语言一样，都是指向对象本身，但是并不是这样。具体为什么，等以后的文章再写。绝对不是我没记清。

既然这样，那我们不妨就顺着这个思路测试一下

看下面代码
```JS
        function foo(num){
            console.log(`foo: ${num}`);
            //记录count被调用的次数
            this.count++;
        }

        foo.count = 0;

        let i;

        for(i=0; i<10; i++){
            if(i>5){
                foo(i)
            }
        }
        //foo: 6
        //foo: 7
        //foo: 8
        //foo: 9

        // foo被调用了多少次
        console.log(foo.count);  // 0  --- wtf
```
foo函数确实被调用了4次，但是foo.count仍然是0.显然this并不指向自身。那么问题来了，this跑到哪了呢？---答案是这段代码创建了一个全局变量count，它的值为NaN。至于为什么是全局的NaN，可以扒其它大佬的文章。

既然this不指向它的自身，那它会不会指向函数的作用域。当然不会
> this在任何情况下都不会指向函数的词法作用域

看到这估计就要烦了，说了这么多，一堆废话，有这空找个姑娘看两样不更好。来了来了，下面就是。
## 调用位置
我们在学习this指向之前要知道它的调用位置：通常来说，寻找调用位置就是寻找“函数被调用的位置”。其中最重要的就是分析调用栈,那我们看看什么是调用栈和调用位置
```JS
        function baz(){
            // 当前的调用栈是baz
            // 因此当前的调用位置是全局作用域

            console.log("baz");
            bar(); // <--bar 的调用位置
        }

        function bar(){
            // 当前的调用栈是baz --> bar
            // 因此当前的调用位置在baz中

            console.log("bar");
            foo(); // foo的调用位置
        }

        function foo(){
            // 当前的调用栈是baz --> bar --> foo
            // 因此当前的调用位置在bar中

            console.log("foo");
        }

        baz(); // baz的调用位置
```
## 绑定规则
我们来看看在函数的执行过程中调用位置如何决定this的绑定对象，一共四条，一条一条来看
### 默认绑定
最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则
```JS
function foo(){
    console.log(this.a);
}
let a = 2;
foo(); // 2
/*
    声明在全局作用域的变量就是全局对象的一个同名属性，它们本质就是同一个东西，并不是通过复制得到的。在代码中。foo是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则
*/
```
### 隐式绑定
相比于默认绑定，隐式绑定要考虑调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含

例如：
```JS
        function foo(){
            console.log(this.a)
        }
        let obj = {
            a: 2,
            foo: foo
        };
        obj.foo(); // 2
```
这个就是一开始说的谁调用this指向谁。而在这个引用链上只有上一层或者说是最后一层在调用位置中起作用

例如：
```JS
        function foo(){
            console.log(this.a)
        }
        let obj2 = {
            a: 42,
            foo: foo
        };

        let obj1 = {
            a: 2,
            obj2: obj1
        };
        obj1.obj2.foo(); // 42
```
而隐式绑定还会发生隐式丢失现象，具体就是把函数当成参数进行调用或者赋值给变量进行调用，这样调用的是函数本身，会被认为是一个不带修饰的函数调用，因此应用了默认绑定
```JS
        function foo(){
            console.log(this.a)
        }
         let obj = {
             a:2,
             foo: foo
         };
         let bar = obj.foo; // 函数别名
         let a = "oops, global"; // a是全局对象的属性
         bar(); // oops, global
```
### 显示绑定
